# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SKtBigT9fg3JEXfg8yBitsXqEhj_94ef
"""

import cv2
import numpy as np
import argparse

def grayscale(image):
    return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

def gaussian_blur(image):
    return cv2.GaussianBlur(grayscale(image), (15, 15), 0)

def canny(image):
    blurred = gaussian_blur(image)
    return cv2.Canny(blurred, 50, 150)

def region_of_interest(image):
    height, width = image.shape[:2]
    polygons = np.array([[
        (int(width * 0.1), int(height)),
        (int(width * 0.9), int(height)),
        (int(width * 0.5), int(height * 0.6))
    ]], dtype=np.int32)
    mask = np.zeros_like(image)
    cv2.fillPoly(mask, polygons, 255)
    return cv2.bitwise_and(image, mask)

def display_lines(image, lines):
    line_image = np.zeros_like(image)
    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line.reshape(4)
            # Draw all detected lines
            cv2.line(line_image, (x1, y1), (x2, y2), (0, 255, 0), 5)
    return line_image

def make_coordinates(image, line_parameters):
    slope, intercept = line_parameters
    y1 = image.shape[0]
    y2 = int(y1 * 0.6)
    x1 = int((y1 - intercept) / slope)
    x2 = int((y2 - intercept) / slope)
    return np.array([x1, y1, x2, y2])

def average_slope_intercept(image, lines):
    left_fit = []
    right_fit = []
    for line in lines:
        x1, y1, x2, y2 = line.reshape(4)
        parameters = np.polyfit((x1, x2), (y1, y2), 1)
        slope = parameters[0]
        intercept = parameters[1]
        if slope < 0:
            left_fit.append((slope, intercept))
        else:
            right_fit.append((slope, intercept))
    left_fit_average = np.average(left_fit, axis=0) if left_fit else (0.01, 0.0)
    right_fit_average = np.average(right_fit, axis=0) if right_fit else (0.01, 0.0)
    left_line = make_coordinates(image, left_fit_average)
    right_line = make_coordinates(image, right_fit_average)
    return np.array([left_line, right_line])

def calculate_lane_curvature_and_offset(image, lines):
    if len(lines) == 2:
        left_line, right_line = lines
        y_eval = image.shape[0]
        left_curverad = ((1 + (2 * left_line[0] * y_eval + left_line[1])**2)**1.5) / np.abs(2 * left_line[0])
        right_curverad = ((1 + (2 * right_line[0] * y_eval + right_line[1])**2)**1.5) / np.abs(2 * right_line[0])
        lane_curvature = (left_curverad + right_curverad) / 2
        lane_center = (left_line[2] + right_line[2]) / 2
        vehicle_offset = (image.shape[1] / 2 - lane_center) * 3.7 / 700
        return lane_curvature, vehicle_offset
    return 0, 0

def calculate_speed(prev_frame, curr_frame, time_interval):
    prev_gray = cv2.cvtColor(prev_frame, cv2.COLOR_BGR2GRAY)
    curr_gray = cv2.cvtColor(curr_frame, cv2.COLOR_BGR2GRAY)
    flow = cv2.calcOpticalFlowFarneback(prev_gray, curr_gray, None, 0.5, 3, 15, 3, 5, 1.2, 0)
    mag, _ = cv2.cartToPolar(flow[..., 0], flow[..., 1])
    speed = np.mean(mag) / time_interval
    return speed

def indicate_lane(speed):
    if speed > 20 and speed < 40:
        return "Maintain current lane"
    elif speed < 20:
        return "Switch to left lane"
    else:
        return "Switch to right lane"

def process_video(video_path, display_time=30):
    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        print(f"Error: Could not open video {video_path}")
        return

    prev_frame = None
    time_interval = 1 / 30

    while cap.isOpened():
        ret, image = cap.read()
        if not ret:
            break

        if prev_frame is not None:
            speed = calculate_speed(prev_frame, image, time_interval)
            lane_indication = indicate_lane(speed)
            cv2.putText(image, f"Speed: {speed:.2f} px/s", (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
            cv2.putText(image, lane_indication, (50, 100), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)

        prev_frame = image.copy()

        canny_image = canny(image)
        roi_image = region_of_interest(canny_image)
        lines = cv2.HoughLinesP(roi_image, 1, np.pi / 180, 50, np.array([]), minLineLength=40, maxLineGap=10)
        if lines is not None:
            averaged_lines = average_slope_intercept(image, lines)
            lane_curvature, vehicle_offset = calculate_lane_curvature_and_offset(image, averaged_lines)
            line_image = display_lines(image, averaged_lines)
            combo_image = cv2.addWeighted(image, 0.8, line_image, 1, 1)
            cv2.putText(combo_image, f"Lane Curvature: {lane_curvature:.2f} m", (50, 150), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
            cv2.putText(combo_image, f"Vehicle Offset: {vehicle_offset:.2f} m", (50, 200), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
        else:
            combo_image = image

        cv2.imshow('Lane Detection', combo_image)
        if cv2.waitKey(display_time) & 0xFF == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Lane Detection on Video")
    parser.add_argument('--video', type=str, required=True, help='Path to the video file')
    parser.add_argument('--display_time', type=int, default=30, help='Display time per frame in milliseconds')
    args = parser.parse_args()

    process_video(args.video, args.display_time)